% Created 2023-09-06 Wed 10:25
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
   \usepackage[T1]{fontenc}
   \setbeamerfont{frametitle}{size=\large}
   \setbeamertemplate{footline}{
   \begin{flushright}
   \insertframenumber/\inserttotalframenumber\hspace{2mm}\mbox{}
   \end{flushright}}
   \usepackage{libertine}
   \usepackage[varqu]{zi4}
   \usepackage[libertine]{newtxmath}
   %%\usepackage[small]{eulervm}
   %%\usepackage[{libertinust1math}
   \usepackage[T1]{fontenc}
   \renewcommand*\familydefault{\sfdefault}
   \usepackage{tipa}
   \usepackage{adjustbox}
   \usepackage{multirow}
   \usepackage{multicol}
   \usepackage[backend=bibtex,uniquename=false,dashed=false,date=year,url=false,isbn=false,style=authoryear-comp]{biblatex}
\addbibresource{/home/juliangrove/Documents/projects/FACTS.lab/ur-comp-sem-2023/ur-comp-sem-2023.bib}
   \usepackage{expex}
   \usepackage{stmaryrd}
   \usepackage{stackrel}
   \usepackage{stackengine}
   \usepackage{relsize}
   \usepackage{amsmath}
   \usepackage{mathtools}
   \usepackage{dsfont}
   \usepackage{fixltx2e}
   \usepackage{graphicx}
   \usepackage{xcolor}
   \usepackage[normalem]{ulem}
\usetheme{metropolis}
\author{Julian Grove}
\date{September 6, 2023}
\title{Haskell: variables, data types, patterns, and recursion}
\usepackage{tikz}
\usetikzlibrary{arrows,arrows.meta,automata}
\usepackage[linguistics]{forest}
\forestset{ downroof/.style={ for children={ if n=1{ edge path'={ (.parent first) -- (!u.parent anchor) -- (!ul.parent last) -- cycle }}{no edge} } } }
\definecolor{highlight}{RGB}{7,102,120}
\definecolor{dim}{RGB}{235,219,178}
\definecolor{dimmer}{RGB}{150,130,50}
\newcommand{\ct}[1]{\textsf{#1}}
\newcommand{\eval}[1]{#1^\lightning}
\newcommand\observe{\mathit{observe}}
\newcommand\reset{\mathit{reset}}
\newcommand\factor{\mathit{factor}}
\def\divd{\ |\ }
\newcommand{\maptyp}[1]{\overline{#1}}
\usepackage[verbose]{newunicodechar}
\newunicodechar{¬¨}{\ensuremath{\neg}} %
\newunicodechar{¬π}{^1}
\newunicodechar{¬≤}{^2}
\newunicodechar{¬≥}{^3}
\newunicodechar{¬∑}{\ensuremath{\cdot}}
\newunicodechar{√ó}{\ensuremath{\times}} %
\newunicodechar{√∑}{\ensuremath{\div}} %
\newunicodechar{·µÖ}{^Œ±}
\newunicodechar{·µù}{^Œ≤}
\newunicodechar{À†}{^Œ≥}
\newunicodechar{·µÉ}{^a}
\newunicodechar{·µá}{^b}
\newunicodechar{·∂ú}{^c}
\newunicodechar{·µà}{^d}
\newunicodechar{·µâ}{^e}
\newunicodechar{·∂†}{^f}
\newunicodechar{·µç}{^g}
\newunicodechar{ ∞}{^h}
\newunicodechar{‚Å±}{^a}
\newunicodechar{ ≤}{^j}
\newunicodechar{·µè}{^K}
\newunicodechar{À°}{^l}
\newunicodechar{·µê}{^m}
\newunicodechar{‚Åø}{^n}
\newunicodechar{·µí}{^o}
\newunicodechar{·µñ}{^p}
\newunicodechar{ ≥}{^r}
\newunicodechar{‚ÇÅ}{_1}
\newunicodechar{‚ÇÇ}{_2}
\newunicodechar{‚ÇÉ}{_3}
\newunicodechar{‚ÇÑ}{_4}
\newunicodechar{‚Çê}{_a}
\newunicodechar{‚Çë}{_e}
\newunicodechar{‚Çï}{_h}
\newunicodechar{·µ¢}{_i}
\newunicodechar{‚Çô}{_n}
\newunicodechar{·µ£}{_r}
\newunicodechar{‚Çõ}{_s}
\newunicodechar{Ã∑}{\not} %
\newunicodechar{Œì}{\ensuremath{\Gamma}}   %
\newunicodechar{Œî}{\ensuremath{\Delta}} %
\newunicodechar{Œó}{\ensuremath{\textrm{H}}} %
\newunicodechar{Œò}{\ensuremath{\Theta}} %
\newunicodechar{Œõ}{\ensuremath{\Lambda}} %
\newunicodechar{Œû}{\ensuremath{\Xi}} %
\newunicodechar{Œ†}{\ensuremath{\Pi}}   %
\newunicodechar{Œ£}{\ensuremath{\Sigma}} %
\newunicodechar{Œ¶}{\ensuremath{\Phi}} %
\newunicodechar{Œ®}{\ensuremath{\Psi}} %
\newunicodechar{Œ©}{\ensuremath{\Omega}} %
\newunicodechar{Œ±}{\ensuremath{\mathnormal{\alpha}}}
\newunicodechar{Œ≤}{\ensuremath{\beta}} %
\newunicodechar{Œ≥}{\ensuremath{\mathnormal{\gamma}}} %
\newunicodechar{Œ¥}{\ensuremath{\mathnormal{\delta}}} %
\newunicodechar{Œµ}{\ensuremath{\mathnormal{\varepsilon}}} %
\newunicodechar{Œ∂}{\ensuremath{\mathnormal{\zeta}}} %
\newunicodechar{Œ∑}{\ensuremath{\mathnormal{\eta}}} %
\newunicodechar{Œ∏}{\ensuremath{\mathnormal{\theta}}} %
\newunicodechar{Œπ}{\ensuremath{\mathnormal{\iota}}} %
\newunicodechar{Œ∫}{\ensuremath{\mathnormal{\kappa}}} %
\newunicodechar{Œª}{\ensuremath{\mathnormal{\lambda}}} %
\newunicodechar{Œº}{\ensuremath{\mathnormal{\mu}}} %
\newunicodechar{ŒΩ}{\ensuremath{\mathnormal{\mu}}} %
\newunicodechar{Œæ}{\ensuremath{\mathnormal{\xi}}} %
\newunicodechar{œÄ}{\ensuremath{\mathnormal{\pi}}}
\newunicodechar{œÄ}{\ensuremath{\mathnormal{\pi}}} %
\newunicodechar{œÅ}{\ensuremath{\mathnormal{\rho}}} %
\newunicodechar{œÉ}{\ensuremath{\mathnormal{\sigma}}} %
\newunicodechar{œÑ}{\ensuremath{\mathnormal{\tau}}} %
\newunicodechar{œÜ}{\ensuremath{\mathnormal{\phi}}} %
\newunicodechar{œá}{\ensuremath{\mathnormal{\chi}}} %
\newunicodechar{œà}{\ensuremath{\mathnormal{\psi}}} %
\newunicodechar{œâ}{\ensuremath{\mathnormal{\omega}}} %
\newunicodechar{œï}{\ensuremath{\mathnormal{\phi}}} %
\newunicodechar{œï}{\ensuremath{\mathnormal{\varphi}}} %
\newunicodechar{œµ}{\ensuremath{\mathnormal{\epsilon}}} %
\newunicodechar{·µè}{^k}
\newunicodechar{·µ¢}{\ensuremath{_i}} %
\newunicodechar{‚ÄÅ}{\quad}
\newunicodechar{‚Ä†}{\dagger}
\newunicodechar{‚ÄØ}{\,}
\newunicodechar{‚Ä≤}{\ensuremath{^\prime}}  %
\newunicodechar{‚Ä≥}{\ensuremath{^\second}} %
\newunicodechar{‚Ä¥}{\ensuremath{^\third}}  %
\newunicodechar{‚Å±}{^i}
\newunicodechar{‚Åµ}{\ensuremath{^5}}
\newunicodechar{‚Å∫}{\ensuremath{^+}} %% #+beamer_header: \newunicodechar{‚Å∫}{^+}
\newunicodechar{‚Åª}{\ensuremath{^-}} %%
\newunicodechar{‚Åø}{^n}
\newunicodechar{‚ÇÄ}{\ensuremath{_0}} %
\newunicodechar{‚ÇÅ}{\ensuremath{_1}} % #+beamer_header: \newunicodechar{‚ÇÅ}{_1}
\newunicodechar{‚ÇÇ}{\ensuremath{_2}} % #+beamer_header: \newunicodechar{‚ÇÇ}{_2}
\newunicodechar{‚ÇÉ}{\ensuremath{_3}}
\newunicodechar{‚Çä}{\ensuremath{_+}} %%
\newunicodechar{‚Çã}{\ensuremath{_-}} %%
\newunicodechar{‚Çô}{_n} %
\newunicodechar{‚ÑÇ}{\ensuremath{\mathbb{C}}} %
\newunicodechar{‚Ñí}{\ensuremath{\mathscr{L}}}
\newunicodechar{‚Ñï}{\mathbb{N}} %
\newunicodechar{‚Ñö}{\ensuremath{\mathbb{Q}}}
\newunicodechar{‚Ñù}{\ensuremath{\mathbb{R}}} %
\newunicodechar{‚Ñ§}{\ensuremath{\mathbb{Z}}} %
\newunicodechar{‚Ñ≥}{\mathscr{M}}
\newunicodechar{‚Öã}{\ensuremath{\parr}} %
\newunicodechar{‚Üê}{\ensuremath{\leftarrow}} %
\newunicodechar{‚Üë}{\ensuremath{\uparrow}} %
\newunicodechar{‚Üí}{\ensuremath{\rightarrow}} %
\newunicodechar{‚Üî}{\ensuremath{\leftrightarrow}} %
\newunicodechar{‚Üñ}{\nwarrow} %
\newunicodechar{‚Üó}{\nearrow} %
\newunicodechar{‚Üù}{\ensuremath{\leadsto}}
\newunicodechar{‚Ü¶}{\ensuremath{\mapsto}}
\newunicodechar{‚áÜ}{\ensuremath{\leftrightarrows}} %
\newunicodechar{‚áê}{\ensuremath{\Leftarrow}} %
\newunicodechar{‚áí}{\ensuremath{\Rightarrow}} %
\newunicodechar{‚áî}{\ensuremath{\Leftrightarrow}} %
\newunicodechar{‚àÄ}{\ensuremath{\forall}}   %
\newunicodechar{‚àÇ}{\ensuremath{\partial}}
\newunicodechar{‚àÉ}{\ensuremath{\exists}} %
\newunicodechar{‚àÖ}{\ensuremath{\varnothing}} %
\newunicodechar{‚àà}{\ensuremath{\in}}
\newunicodechar{‚àâ}{\ensuremath{\not\in}} %
\newunicodechar{‚àã}{\ensuremath{\ni}}  %
\newunicodechar{‚àé}{\ensuremath{\qed}}%#+beamer_header: \newunicodechar{‚àé}{\ensuremath{\blacksquare}} % end of proof
\newunicodechar{‚àè}{\prod}
\newunicodechar{‚àë}{\sum}
\newunicodechar{‚àó}{\ensuremath{\ast}} %
\newunicodechar{‚àò}{\ensuremath{\circ}} %
\newunicodechar{‚àô}{\ensuremath{\bullet}} % #+beamer_header: \newunicodechar{‚àô}{\ensuremath{\cdot}}
\newunicodechar{‚äô}{\ensuremath{\odot}}
\newunicodechar{‚àû}{\ensuremath{\infty}} %
\newunicodechar{‚à£}{\ensuremath{\mid}} %
\newunicodechar{‚àß}{\wedge}%
\newunicodechar{‚à®}{\vee}%
\newunicodechar{‚à©}{\ensuremath{\cap}} %
\newunicodechar{‚à™}{\ensuremath{\cup}} %
\newunicodechar{‚à´}{\int}
\newunicodechar{‚à∑}{::} %
\newunicodechar{‚àº}{\ensuremath{\sim}} %
\newunicodechar{‚âÉ}{\ensuremath{\simeq}} %
\newunicodechar{‚âî}{\ensuremath{\coloneqq}} %
\newunicodechar{‚âÖ}{\ensuremath{\cong}} %
\newunicodechar{‚âà}{\ensuremath{\approx}} %
\newunicodechar{‚âú}{\ensuremath{\stackrel{\scriptscriptstyle {\triangle}}{=}}} % #+beamer_header: \newunicodechar{‚âú}{\triangleq}
\newunicodechar{‚âù}{\ensuremath{\stackrel{\scriptscriptstyle {\text{def}}}{=}}}
\newunicodechar{‚âü}{\ensuremath{\stackrel {_\text{\textbf{?}}}{\text{\textbf{=}}\negthickspace\negthickspace\text{\textbf{=}}}}} % or {\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\newunicodechar{‚â†}{\ensuremath{\neq}}%
\newunicodechar{‚â°}{\ensuremath{\equiv}}%
\newunicodechar{‚â§}{\ensuremath{\le}} %
\newunicodechar{‚â•}{\ensuremath{\ge}} %
\newunicodechar{‚äÇ}{\ensuremath{\subset}} %
\newunicodechar{‚äÉ}{\ensuremath{\supset}} %
\newunicodechar{‚äÜ}{\ensuremath{\subseteq}} %
\newunicodechar{‚äá}{\ensuremath{\supseteq}} %
\newunicodechar{‚äé}{\ensuremath{\uplus}} %
\newunicodechar{‚äë}{\ensuremath{\sqsubseteq}} %
\newunicodechar{‚äí}{\ensuremath{\sqsupseteq}} %
\newunicodechar{‚äì}{\ensuremath{\sqcap}} %
\newunicodechar{‚äî}{\ensuremath{\sqcup}} %
\newunicodechar{‚äï}{\ensuremath{\oplus}} %
\newunicodechar{‚äó}{\ensuremath{\otimes}} %
\newunicodechar{‚äõ}{\ensuremath{\circledast}}
\newunicodechar{‚ä¢}{\ensuremath{\vdash}} %
\newunicodechar{‚ä§}{\ensuremath{\top}}
\newunicodechar{‚ä•}{\ensuremath{\bot}} % bottom
\newunicodechar{‚äß}{\models} %
\newunicodechar{‚ä®}{\models} %
\newunicodechar{‚ä©}{\Vdash}
\newunicodechar{‚ä∏}{\ensuremath{\multimap}} %
\newunicodechar{‚ãÅ}{\ensuremath{\bigvee}}
\newunicodechar{‚ãÉ}{\ensuremath{\bigcup}} %
\newunicodechar{‚ãÑ}{\ensuremath{\diamond}} %
\newunicodechar{‚ãÖ}{\ensuremath{\cdot}}
\newunicodechar{‚ãÜ}{\ensuremath{\star}} %
\newunicodechar{‚ãÆ}{\ensuremath{\vdots}} %
\newunicodechar{‚ãØ}{\ensuremath{\cdots}} %
\newunicodechar{‚îÄ}{---}
\newunicodechar{‚ñ†}{\ensuremath{\blacksquare}} % black square
\newunicodechar{‚ñ°}{\ensuremath{\square}} %
\newunicodechar{‚ñ¥}{\ensuremath{\blacktriangledown}}
\newunicodechar{‚ñµ}{\ensuremath{\triangle}}
\newunicodechar{‚ñπ}{\ensuremath{\triangleright}} %
\newunicodechar{‚ñæ}{\ensuremath{\blacktriangle}}
\newunicodechar{‚ñø}{\ensuremath{\triangledown}}
\newunicodechar{‚óÉ}{\triangleleft{}}
\newunicodechar{‚óÖ}{\ensuremath{\triangleleft{}}}
\newunicodechar{‚óá}{\ensuremath{\diamond}} %
\newunicodechar{‚óΩ}{\ensuremath{\square}}
\newunicodechar{‚òÖ}{\ensuremath{\star}}   %
\newunicodechar{‚ô≠}{\ensuremath{\flat}} %
\newunicodechar{‚ôØ}{\ensuremath{\sharp}} %
\newunicodechar{‚úì}{\ensuremath{\checkmark}} %
\newunicodechar{‚üÇ}{\ensuremath{^\bot}} % PERPENDICULAR
\newunicodechar{‚ü¶}{\ensuremath{\llbracket}}
\newunicodechar{‚üß}{\ensuremath{\rrbracket}}
\newunicodechar{‚¶á}{\ensuremath{\llparenthesis}}
\newunicodechar{‚¶à}{\ensuremath{\rrparenthesis}}
\newunicodechar{‚ü®}{\ensuremath{\langle}} %
\newunicodechar{‚ü©}{\ensuremath{\rangle}} %
\newunicodechar{‚åú}{\ensuremath{\ulcorner}} %
\newunicodechar{‚åù}{\ensuremath{\urcorner}} %
\newunicodechar{‚ü∂}{{\longrightarrow}}
\newunicodechar{‚ü∑} {\ensuremath{\leftrightarrow}}
\newunicodechar{‚üπ}{\ensuremath{\Longrightarrow}} %
\newunicodechar{‚±º}{_j} %
\newunicodechar{ùíü}{\ensuremath{\mathcal{D}}} %
\newunicodechar{ùí¢}{\ensuremath{\mathcal{G}}}
\newunicodechar{ùí¶}{\ensuremath{\mathcal{K}}} %
\newunicodechar{ùí´}{\ensuremath{\mathcal{P}}}
\newunicodechar{ùî∏}{\ensuremath{\mathds{A}}} %
\newunicodechar{ùîπ}{\ensuremath{\mathds{B}}} %
\newunicodechar{ùüô}{\ensuremath{\mathds{1}}} %
\newunicodechar{ùîº}{\mathds{E}}
\newunicodechar{‚ä¨}{\not \vdash}
\newunicodechar{‚àù}{\propto}
\newunicodechar{·∂ø}{^\theta}
\institute[University of Rochester]{FACTS.lab, University of Rochester}
\hypersetup{
 pdfauthor={Julian Grove},
 pdftitle={Haskell: variables, data types, patterns, and recursion},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.6.6)}, 
 pdflang={English}}
\begin{document}

\maketitle

\section{Introduction}
\label{sec:org9fb5694}

\begin{frame}[label={sec:orga52ce46}]{Last time}
We looked at some basic data types, functions, fixity, and type inference.
\end{frame}

\begin{frame}[label={sec:org9576599}]{This time}
We'll look at some of the stuff Haskell was made for.
\pause
\begin{itemize}[<+->]
\item Anonymous functions (i.e., function literals)
\item Role-your-own data types (i.e., algebraic data types)
\item Recursion via pattern matching
\end{itemize}
\end{frame}

\section{Variables}
\label{sec:org57238fb}
\begin{frame}[label={sec:org56df7d7},fragile]{\texttt{let} bindings}
 A \texttt{let} binding can be used to define a local variable anywhere you want.
\end{frame}

\begin{frame}[label={sec:org537dab7},fragile]{\texttt{where} clauses}
 A \texttt{where} clause can be used to define a local variable inside of another
definition.
\end{frame}

\begin{frame}[label={sec:orgef068dd},fragile]{Anonymous functions}
 Functions are first-class in Haskell, so they are treated like other data. \\[0pt]
\pause \bigskip
This means that we can write function \emph{literals}. \\[0pt]
\pause \bigskip
We do this by binding the variad to make \texttt{Fruit} an instance of the typeclass \texttt{Show}.
\begin{itemize}
\item Two ways to do this\ldots{}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgb0b6e26},fragile]{Sum types}
 \texttt{Fruit} is what is called a \emph{sum type}.
\pause
\begin{itemize}[<+->]
\item It enumerates all values it can have in different branches, delimiting them
with a \texttt{|}.
\item In each branch is what is called a \emph{data constructor}.
\item The name of a data constructor in Haskell must begin with a capital letter.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org083e2e8},fragile]{N-ary constructors}
 The \texttt{Fruit} sum type is an odd special case, in that the data constructors
don't carry an extra data besides their identity. \\[0pt]
\pause \bigskip
Something more common might have data constructors carry additional data,
e.g., one data constructor could carry a \texttt{Bool} and one could carry a \texttt{String}.
\pause
\begin{itemize}[<+->]
\item This can allow us to write functions that take \emph{either} a \texttt{Bool} \emph{or} a \texttt{String} as
its input, using \emph{pattern matching}.
\end{itemize}
\pause \bigskip
By the way, you might be wondering: if a data constructor can take an
argument, does that mean it's a function?
\pause
\begin{itemize}[<+->]
\item The answer is ``yes''!
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org9cfe40e},fragile]{Pattern matching: order matters}
 Pattern branches get checked in top-to-bottom order.
\pause
\begin{itemize}[<+->]
\item For example\ldots{}
\item Flipping the branches makes the definition effectively stop at the first
branch, since \texttt{str} is a wildcard over all possible strings.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgf1269f4},fragile]{Case expressions}
 You can also use a \emph{case expression} to do pattern matching. \\[0pt]
\pause \bigskip
Case expressions do more than just pattern match---they also evaluate the
expression between the \texttt{case} and the \texttt{of}\ldots{}
\end{frame}

\begin{frame}[label={sec:org60a6096},fragile]{As patterns}
 An \emph{as pattern} (written with an \texttt{@} sign) allows you to bind an identifier to
the an argument which has been deconstructed into a pattern\ldots{}
\end{frame}

\begin{frame}[label={sec:org6820b80},fragile]{Pattern guards}
 Pattern guards are useful when you want to further restrict the applicability
of a branch of a definition to patterns that satisfy some boolean condition.
\\[0pt]
\pause \bigskip
You use a \texttt{|} after the relevant pattern and then state the condition\ldots{}
\end{frame}

\section{Recursive definitions}
\label{sec:orgb7c6e4d}
\begin{frame}[label={sec:org5cfc2b1}]{Lists}
We talked a little about lists last time. \\[0pt]
\pause \bigskip
Lists are deeply baked into Haskell, so we can't look at the source code. \\[0pt]
\pause \bigskip
But we can roll our own\ldots{}
\end{frame}

\begin{frame}[label={sec:org3b3c92a},fragile]{Haskell lists}
 For convenience, Haskell lets you type, e.g., \texttt{['a', 's', 'd', 'f']} for a list
literal. \\[0pt]
\pause \bigskip
When you see this, you should have in mind the following:
\begin{center}
\texttt{('a' : ('s' : ('d' : ('f' : []))))}
\end{center}
\pause \bigskip
Everything is one of two cases; either:
\pause
\begin{itemize}[<+->]
\item any empty list
\item something cons-ed onto a list
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1e8f36f},fragile]{Appending stuff}
 Let's define our first recursive function: \texttt{append}.
\end{frame}

\begin{frame}[label={sec:org40a047e},fragile]{\texttt{[a]} to \texttt{List a}}
 How could we write a recursive function that maps values of type \texttt{List a} to
values of type \texttt{[a]}?
\end{frame}

\begin{frame}[label={sec:org4c7cd6b},fragile]{\texttt{map}}
 Haskell has a built-in function \texttt{map} for mapping functions of type \texttt{a -> b} to
functions from lists of \texttt{a}'s to lists of \texttt{b}'s.
\begin{center}
\texttt{map :: (a -> b) -> [a] -> [b]}
\end{center}
How does \texttt{map} work?\ldots{}
\pause
\begin{itemize}[<+->]
\item We need a branch in the definition that applies to the empty list.
\item We need a branch in the definition that applies to non-empty lists.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgb5db6ae},fragile]{\texttt{filter}}
 Filter takes a predicate, i.e., a function of from \texttt{a}'s to \texttt{Bool}'s, along with
a list of \texttt{a}'s, in order to give back a list of the \texttt{a}'s that satisfy the
predicate.
\begin{center}
\texttt{filter :: (a -> Bool) -> [a] -> [a]}
\end{center}
How does \texttt{filter} work?\ldots{}
\pause
\begin{itemize}[<+->]
\item We need a branch in the definition that applies to the empty list.
\item We need a branch in the definition that applies to non-empty lists.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgac1012c},fragile]{\texttt{foldr} and \texttt{foldl}}
 Haskell has functions \texttt{foldr} and \texttt{foldl} that each take a two-place operation, a
starting value, and some list, in order to iteratively apply the function to
the elements of the list, one-by-one.
\begin{center}
\texttt{foldr :: (a -> b -> b) -> b -> [a] -> b} \\[0pt]
\texttt{foldl :: (b -> a -> b) -> b -> [a] -> b}
\end{center}
\end{frame}

\begin{frame}[label={sec:org465d58b},fragile]{\texttt{foldr}}
 \texttt{foldr}, in a way, conceptualizes a list as right-branching. \\[0pt]
\begin{center}
\begin{forest}
[{+} [ 7 ] [{+} [ 8 ] [{+} [ 9 ] [{+} [ 10 ] [ 0 ] ] ] ] ]
\end{forest}
\end{center}
\end{frame}

\begin{frame}[label={sec:orgdace915},fragile]{\texttt{foldl}}
 \texttt{foldl} conceptualizes it as left-branching. \\[0pt]
\begin{center}
\begin{forest}
[{+} [{+} [{+} [{+} [ 0 ] [ 7 ] ] [ 8 ] ] [ 9 ] ] [ 10 ] ] ] ] ]
\end{forest}
\end{center}
\end{frame}
\end{document}