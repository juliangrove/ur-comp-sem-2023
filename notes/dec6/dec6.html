<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-12-13 Wed 18:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Updating a probabilistic context set</title>
<meta name="author" content="Julian Grove" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
<script src="../../jquery.min.js"></script>
<script src="../../bootstrap.min.js"></script>
<script type="text/javascript" src="../../readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Updating a probabilistic context set</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9801606">1. Overview</a></li>
<li><a href="#org28c3994">2. Context sets as probability distributions</a></li>
<li><a href="#orgeaad7c8">3. Updating context sets with English sentences</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9801606" class="outline-2">
<h2 id="org9801606"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
This short set of notes shows how we may begin to use our probabilistic DSL,
along with its associated interpretation scheme, to describe common grounds as
probability distributions over sets of possible worlds, and sentence
interpretations as <i>updates</i> to such sets.
</p>
</div>
</div>

<div id="outline-container-org28c3994" class="outline-2">
<h2 id="org28c3994"><span class="section-number-2">2.</span> Context sets as probability distributions</h2>
<div class="outline-text-2" id="text-2">
<p>
How might that be done? Let's say we have a constant
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fb4933;">data</span> <span style="color: #d3869b;">Constant</span> (&#966; <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Type</span>) <span style="color: #fb4933;">where</span>
  <span style="color: #83a598;">...</span>
  <span style="color: #d3869b;">WorldKnowledge</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">P</span> <span style="color: #d3869b;">I</span>
  <span style="color: #83a598;">...</span>
</pre>
</div>
<p>
representing a probabilistic program that returns possible worlds. Such a
constant can represent a starting common ground; that is, a probability
distribution over the set of possible worlds determined by our general world
knowledge&#x2014;knowledge of which sets of facts are probable.
</p>

<p>
For example, we might want to consider four possible worlds, where each one
settles whether or not Julian sleeps, as well as whether or not Carina
sleeps. Then to <code>WorldKnowledge</code>, we might assign the meaning
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">interpCon</span> <span style="color: #fb4933;">_</span> <span style="color: #d3869b;">WorldKnowedge</span> <span style="color: #83a598;">=</span> worldKnowledge
  <span style="color: #fb4933;">where</span> worldKnowledge <span style="color: #83a598;">::</span> <span style="color: #d3869b;">ProbProg</span> [<span style="color: #d3869b;">FOL.Form</span>]
        worldKnowledge <span style="color: #83a598;">=</span> <span style="color: #fb4933;">do</span> f1 <span style="color: #83a598;">&lt;-</span> categorical [0.5, 0.5] [id, <span style="color: #d3869b;">FOL.Not</span>]
                            f2 <span style="color: #83a598;">&lt;-</span> categorical [0.5, 0.5] [id, <span style="color: #d3869b;">FOL.Not</span>]
                            return [ f1 (sleep (<span style="color: #d3869b;">FOL.N</span> (<span style="color: #d3869b;">FOL.Name</span> 0)))
                                   , f2 (sleep (<span style="color: #d3869b;">FOL.N</span> (<span style="color: #d3869b;">FOL.Name</span> 1))) ]
        categorical <span style="color: #83a598;">::</span> [<span style="color: #d3869b;">Double</span>] <span style="color: #83a598;">-&gt;</span> [a] <span style="color: #83a598;">-&gt;</span> <span style="color: #d3869b;">ProbProg</span> a
        categorical ws vs <span style="color: #83a598;">=</span> <span style="color: #d3869b;">PP</span> (<span style="color: #83a598;">\</span>f <span style="color: #83a598;">-&gt;</span> sum (zipWith (<span style="color: #83a598;">*</span>) ws (map f vs)))
</pre>
</div>
<p>
Here, <code>worldKnowledge</code> returns any of these four possible worlds with equal
probability&#x2014;it thus provides a kind of uniform distribution. Note the use in
its definition of a function <code>categorical</code>, which takes a list of numbers, along
with a list of values of the same length, in order to give back a
probabilistic program that returns the \(n\)th value with probability
proportional to the \(n\)th number. For example,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">categorical</span> [1, 2, 3] [<span style="color: #b8bb26;">'a'</span>, <span style="color: #b8bb26;">'b'</span>, <span style="color: #b8bb26;">'c'</span>]
</pre>
</div>
<p>
is a probabilistic program of type <code>ProbProg Char</code> which returns <code>'a'</code> with
probability \(1/(1 + 2 + 3) = 1/6\), <code>'b'</code> with probability \(1/3\) and <code>'c'</code> with
probability \(1/2\). <code>categorical</code> is defined using <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#v:zipWith"><code>zipWith</code></a>, which allows a
weight to be paired up with each value that might be returned.
</p>
</div>
</div>

<div id="outline-container-orgeaad7c8" class="outline-2">
<h2 id="orgeaad7c8"><span class="section-number-2">3.</span> Updating context sets with English sentences</h2>
<div class="outline-text-2" id="text-3">
<p>
What we would like to do now is to determine a way of interpreting sentences
of English as true or false at a given possible world, and to use such an
interpretation scheme to update a context set&#x2014;which are encoding as a
probability distribution over possible worlds&#x2014;given a sentence. One way we
can do this is by encoding an <i>interpretation function</i> directly in our
λ-calculus; that is, a map from sentences to sets of possible worlds.
</p>

<p>
To set this up, we should introduce a new atomic type <code>U</code> for <i>utterances</i> to our
λ-calculus, so that our full set of types is
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fb4933;">data</span> <span style="color: #d3869b;">Type</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">E</span> <span style="color: #83a598;">|</span> <span style="color: #d3869b;">T</span> <span style="color: #83a598;">|</span> <span style="color: #d3869b;">I</span> <span style="color: #83a598;">|</span> <span style="color: #d3869b;">U</span> <span style="color: #83a598;">|</span> <span style="color: #d3869b;">R</span>
          <span style="color: #83a598;">|</span> <span style="color: #d3869b;">Type</span> <span style="color: #d3869b;">:-&gt;</span> <span style="color: #d3869b;">Type</span>
          <span style="color: #83a598;">|</span> <span style="color: #d3869b;">Type</span> <span style="color: #d3869b;">:/\</span> <span style="color: #d3869b;">Type</span>
          <span style="color: #83a598;">|</span> <span style="color: #d3869b;">Unit</span>
          <span style="color: #83a598;">|</span> <span style="color: #d3869b;">P</span> <span style="color: #d3869b;">Type</span>
</pre>
</div>
<p>
The type family <code>Domain</code> should then be extended, in order to handle utterances.
These can be interpreted as Haskell values of type <code>Expr S</code> (i.e., we may
represent an utterance using our Haskell encoding of English sentences).
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fb4933;">type</span> <span style="color: #fb4933;">family</span> <span style="color: #d3869b;">Domain</span> (&#966; <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Type</span>) <span style="color: #fb4933;">where</span>
  <span style="color: #d3869b;">Domain</span> <span style="color: #d3869b;">E</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">FOL.Term</span>
  <span style="color: #d3869b;">Domain</span> <span style="color: #d3869b;">T</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">FOL.Form</span>
  <span style="color: #d3869b;">Domain</span> <span style="color: #d3869b;">I</span> <span style="color: #83a598;">=</span> [<span style="color: #d3869b;">FOL.Form</span>]
  <span style="color: #d3869b;">Domain</span> <span style="color: #d3869b;">U</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">Expr</span> <span style="color: #d3869b;">S</span>
  <span style="color: #d3869b;">Domain</span> <span style="color: #d3869b;">R</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">Double</span>
  <span style="color: #d3869b;">Domain</span> (&#966; <span style="color: #d3869b;">:-&gt;</span> &#968;) <span style="color: #83a598;">=</span> <span style="color: #d3869b;">Domain</span> &#966; <span style="color: #83a598;">-&gt;</span> <span style="color: #d3869b;">Domain</span> &#968;
  <span style="color: #d3869b;">Domain</span> (&#966; <span style="color: #d3869b;">:/\</span> &#968;) <span style="color: #83a598;">=</span> (<span style="color: #d3869b;">Domain</span> &#966;, <span style="color: #d3869b;">Domain</span> &#968;)
  <span style="color: #d3869b;">Domain</span> <span style="color: #d3869b;">Unit</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">()</span>
  <span style="color: #d3869b;">Domain</span> (<span style="color: #d3869b;">P</span> &#966;) <span style="color: #83a598;">=</span> <span style="color: #d3869b;">ProbProg</span> (<span style="color: #d3869b;">Domain</span> &#966;)
</pre>
</div>

<p>
Finally, we should add a couple of new constants to our λ-calculus which will
allow us to both represent and interpret English utterances.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fb4933;">data</span> <span style="color: #d3869b;">Constant</span> (&#966; <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Type</span>) <span style="color: #fb4933;">where</span>
  <span style="color: #83a598;">...</span>
  <span style="color: #d3869b;">ToUtt</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Expr</span> <span style="color: #d3869b;">S</span> <span style="color: #83a598;">-&gt;</span> <span style="color: #d3869b;">Constant</span> <span style="color: #d3869b;">U</span>
  <span style="color: #d3869b;">Interp</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Constant</span> (<span style="color: #d3869b;">U</span> <span style="color: #d3869b;">:-&gt;</span> (<span style="color: #d3869b;">I</span> <span style="color: #d3869b;">:-&gt;</span> <span style="color: #d3869b;">T</span>))
  <span style="color: #83a598;">...</span>
</pre>
</div>
<p>
<code>ToUtt</code> allows us to represent an English expression (encoded in our applicative
categorial grammar fragment) in the λ-calculus, as term of type <code>U</code>, while
<code>Interp</code> allows us to take an utterance onto what is effectively a set of
worlds&#x2014;that is, a function of type <code>I :-&gt; T</code>. We may in turn interpret these
constants by extending our definition of <code>interpCon</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">interpCon</span> <span style="color: #fb4933;">_</span> (<span style="color: #d3869b;">ToUtt</span> u) <span style="color: #83a598;">=</span> u
<span style="color: #fabd2f;">interpCon</span> <span style="color: #fb4933;">_</span> <span style="color: #d3869b;">Interp</span> <span style="color: #83a598;">=</span> <span style="color: #83a598;">\</span>&#966; i <span style="color: #83a598;">-&gt;</span> <span style="color: #fb4933;">if</span> entails 11
                            (englishToFOL &#966; <span style="color: #d3869b;">:</span> i)
                            false
                            <span style="color: #fb4933;">then</span> false
                            <span style="color: #fb4933;">else</span> true
</pre>
</div>
<p>
Recall from <a href="../nov20/nov20.html#org0f0d2be">here</a> that <code>englishToFOL</code> is defined as
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">englishToFOL</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Expr</span> <span style="color: #d3869b;">S</span> <span style="color: #83a598;">-&gt;</span> <span style="color: #d3869b;">FOL.Form</span>
<span style="color: #fabd2f;">englishToFOL</span> <span style="color: #83a598;">=</span> interpClosedTerm <span style="color: #83a598;">.</span> lower <span style="color: #83a598;">.</span> interpExpr
</pre>
</div>
<p>
Thus for an English sentence to be <i>true</i> at some possible world is for its
translation into first-order logic to be logically compatible with the
formulae which are true at that possible world.
</p>

<p>
We are now able to encode discourses involving English sentences (woohoo!)?
Take the following one, for instance.
\[\begin{array}{l}w ∼ worldKnowledge \\ observe(⟦\textit{someone sleeps}⟧^w)
  \\ return(w)\end{array}\]
We can encode this discourse as a probabilistic program in our λ-calculus as
follows:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">example</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Term</span> &#947; (<span style="color: #d3869b;">P</span> <span style="color: #d3869b;">I</span>)
<span style="color: #fabd2f;">example</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">Let</span> (<span style="color: #d3869b;">Con</span> <span style="color: #d3869b;">WorldKnowledge</span>) (<span style="color: #d3869b;">Let</span> (<span style="color: #d3869b;">App</span> observe (<span style="color: #d3869b;">App</span> (<span style="color: #d3869b;">App</span> (<span style="color: #d3869b;">Con</span> <span style="color: #d3869b;">Interp</span>) (<span style="color: #d3869b;">Con</span> (<span style="color: #d3869b;">ToUtt</span> someoneSleeps))) (<span style="color: #d3869b;">Var</span> <span style="color: #d3869b;">First</span>))) (<span style="color: #d3869b;">Return</span> (<span style="color: #d3869b;">Var</span> (<span style="color: #d3869b;">Next</span> <span style="color: #d3869b;">First</span>))))
</pre>
</div>
<p>
Recall that <code>observe</code> is defined by applying <code>Factor</code> to the indicator function.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">observe</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">Term</span> &#947; (<span style="color: #d3869b;">T</span> <span style="color: #d3869b;">:-&gt;</span> <span style="color: #d3869b;">P</span> <span style="color: #d3869b;">Unit</span>)
<span style="color: #fabd2f;">observe</span> <span style="color: #83a598;">=</span> <span style="color: #d3869b;">Lam</span> (<span style="color: #d3869b;">App</span> (<span style="color: #d3869b;">Con</span> <span style="color: #d3869b;">Factor</span>) (<span style="color: #d3869b;">App</span> (<span style="color: #d3869b;">Con</span> <span style="color: #d3869b;">Indi</span>) (<span style="color: #d3869b;">Var</span> <span style="color: #d3869b;">First</span>)))
</pre>
</div>

<p>
Indeed, if we interpret this new context set and check whether or not Carina
sleeps in the result,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">runTest</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">ProbProg</span> <span style="color: #d3869b;">Bool</span>
<span style="color: #fabd2f;">runTest</span> <span style="color: #83a598;">=</span> <span style="color: #fb4933;">do</span> i <span style="color: #83a598;">&lt;-</span> interpClosedTerm example
             return (entails 11 i (sleep (<span style="color: #d3869b;">FOL.N</span> (<span style="color: #d3869b;">FOL.Name</span> 0))))
</pre>
</div>
<p>
we get a program in Haskell from which we may extract a probability. To do
this, we may define a function
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">p</span> <span style="color: #83a598;">::</span> <span style="color: #d3869b;">ProbProg</span> <span style="color: #d3869b;">Bool</span> <span style="color: #83a598;">-&gt;</span> <span style="color: #d3869b;">Double</span>
<span style="color: #fabd2f;">p</span> m <span style="color: #83a598;">=</span> expVal m indi
</pre>
</div>
<p>
which takes the expected value of the indicator function; that is, it computes
a <i>probability</i> from a program of type <code>ProbProg Bool</code> as the proportion of the
mass it assigns to either <code>True</code> or <code>False</code> that it assigns to <code>True</code>. Now we can
take the probability of <code>runTest</code>!
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #83a598;">&gt;&gt;&gt;</span> p runTest
0.6666666666666666
</pre>
</div>
<p>
Hm, why do you think this is the result?
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Julian Grove</p>
<p class="date">Created: 2023-12-13 Wed 18:36</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
