#+html_head: <link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
#+html_head: <link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
#+html_head: <script src="../../jquery.min.js"></script>
#+html_head: <script src="../../bootstrap.min.js"></script>
#+html_head: <script type="text/javascript" src="../../readtheorg.js"></script>

#+Author: Julian Grove
#+Title: Church encodings

* Review
  We looked at Church encodings of four different data types:
  - Booleans
  - Natural numbers
  - Pairs
  - Lists

** Booleans
   Booleans can be one of two values, $ğ•‹$ and $ğ”½$. In Haskell, they are
   represented by the algebraic data type ~Bool~:
   #+begin_src haskell
     data Bool = True | False
   #+end_src
   In Î»-calculus we can represent them as two Î»-terms:
   $$ğ•‹ â‰ Î»x, y.x$$
   $$ğ”½ â‰ Î»x, y.y$$
   Defining Booleans this way allows us to define fun operations on Booleans,
   such as:
   $$\mathtt{ifThenElse} â‰ Î»p, x, y.p\,x\,y$$
   $$\mathtt{not} â‰ Î»p.p\,ğ”½\,ğ•‹$$
   $$\mathtt{and} â‰ Î»p, q.p\,q\,ğ”½$$
   $$\mathtt{or} â‰ Î»p, q.p\,ğ•‹\,q$$

** Natural numbers
   The natural numbers 0, 1, 2, etc., can be encoded in Haskell by the algebraic
   data type ~Nat~:
   #+begin_src haskell
     data Nat = Zero | Succ Nat
   #+end_src
   In Î»-calculus we can represent them by using the following translation
   ($âŒœÂ·âŒ$):
   $$âŒœ0âŒ â‰ Î»s, z.z$$
   $$âŒœ\mathtt{Succ}\,nâŒ â‰ Î»s, z.s\,(âŒœnâŒ\,s\,z)$$
   For example, $1$ (i.e., $\mathtt{Succ}\,0$) would receive the translation
   $âŒœ\mathtt{Succ}\,0âŒ = Î»s, z.s\,(âŒœ0âŒ\,s\,z) = Î»s, z.s\,((Î»s, z.z)\,s\,z)
   â†’_Î²^* Î»s, z.s\,(s\,z)$. In general, the number of occurrences of the variable
   bound by the outer abstraction in the encoding of a natural number is just
   that number.

   We can now define functions on natural numbers, such as
   $$\mathtt{succ} â‰ Î»n, s, z.s\,(n\,s\,z)$$
   i.e., the successor function, which, given a natural number, takes its
   successor. Other useful operations are
   $$\mathtt{plus} â‰ Î»m, n.m\,\mathtt{succ}\,n$$
   which takes the successor of $n$ $m$ times, and
   $$\mathtt{mult} â‰ Î»m, n.m\,(\mathtt{plus}\,n)\,âŒœ0âŒ$$
   which adds $n$ to $0$ $m$ times.

** Pairing
   Taking a pair of two values can be done as follows:
   $$âŒœâŸ¨a, bâŸ©âŒ â‰ Î»f.f\,âŒœaâŒ\,âŒœbâŒ$$
   Given this encoding of pairing, we may define the following two /projection
   functions/, which take the first and second projections of a pair,
   respectively:
   $$Ï€â‚ â‰ Î»p.p\,ğ•‹$$
   $$Ï€â‚‚ â‰ Î»p.p\,ğ”½$$
   In Haskell, these functions correspond to the functions
   #+begin_src haskell
     fst :: (a, b) -> a
     snd :: (a, b) -> b
   #+end_src
   which give back the first and second projections of a pair, respectively.

** Lists
   Finally, lists! In Haskell, these are encoded as an algebraic data type
   (equivalent to)
   #+begin_src haskell
     data List a = Empty | Cons a (List a)
   #+end_src
   In the Î»-calculus, we may define them as using the translation
   $$âŒœ[]âŒ â‰ Î»c, n.n$$
   $$âŒœa : lâŒ â‰ Î»c, n.c\,âŒœaâŒ\,(âŒœlâŒ\,c\,n)$$
   For example, the the list $[1]$ would be translated as $âŒœ[1]âŒ = Î»c,
   n.c\,âŒœ1âŒ(âŒœ[]âŒ\,c\,n) = Î»c, n.c\,âŒœ1âŒ\,((Î»c, n.n)\,c\,n) â†’_Î²^* Î»c,
   n.c\,âŒœ1âŒ\,n$.

   We can now, e.g., take the length of a list in terms of a function
   $$\mathtt{length} â‰ Î»l.l\,(Î»x.\mathtt{succ})\,âŒœ0âŒ$$
   and we can, e.g., take the head (i.e., first element) of a list using a
   function
   $$\mathtt{head} â‰ Î»l.l\,ğ•‹\,ğ”½$$
   Note that, if passed the empty list, $\mathtt{head}$ just gives back $ğ”½$.
   
* Exercises
** Part 1
   Compute $\mathtt{plus}\,âŒœ2âŒ\,âŒœ3âŒ$.
   
** Part 2
   Define a function $\mathtt{ifThen}$ which takes two truth values and gives
   back $ğ•‹$ if the first truth value is $ğ”½$ or the second truth value is $ğ•‹$ (or
   if both the first is $ğ”½$ and the second is $ğ•‹$). Do this without using either
   $\mathtt{not}$ or $\mathtt{or}$ in your definition!

** Part 3
   Define a function $\mathtt{append}$ which takes two lists and appends
   them. That is, $\mathtt{append}$ should have the following behavior:
   $$\mathtt{append}\,âŒœ[]âŒ\,l â‰¡_Î² l$$
   $$\mathtt{append}\,âŒœa : lâ‚âŒ\,lâ‚‚ â‰¡_Î² Î»c, n.c\,âŒœaâŒ\,(\mathtt{append}\,lâ‚\,lâ‚‚)$$

** Part 4
   Define a function $\mathtt{all}$ which, given a list of Booleans (i.e.,
   either $ğ•‹$ or $ğ”½$), returns $ğ•‹$ if all of them are $ğ•‹$ and returns $ğ”½$
   otherwise.

** Part 5
   Define a function $\mathtt{any}$ which, given a list of Booleans (i.e.,
   either $ğ•‹$ or $ğ”½$), returns $ğ•‹$ if any of them is $ğ•‹$ and returns $ğ”½$
   otherwise.

** Part 6
   Define a function $\mathtt{sum}$ which, given a list of natural numbers,
   returns their sum.

** Part 7
   Define a function $\mathtt{map}$ which, given a function $f$ from \(a\)'s to
   \(b\)'s, applies $f$ to each member of a list of \(a\)'s to get back a list
   of \(b\)'s. That is, $\mathtt{map}$ should have the following behavior:
   $$\mathtt{map}\,f\,âŒœ[]âŒ â‰¡_Î² âŒœ[]âŒ$$
   $$\mathtt{map}\,f\,âŒœa : lâŒ â‰¡_Î² Î»c, n.c\,(f\,âŒœaâŒ)\,(\mathtt{map}\,f\,âŒœlâŒ\,c\,n)$$

** Part 8
   Define a function $\mathtt{filter}$ which, given a function $f$ from \(a\)'s
   to Booleans and a list of \(a\)'s, filters the list using $f$. That is, it
   returns a new list of \(a\)'s such that $x$ is on the new list just in case
   $x$ was on  the old list and $f x â†’_Î²^* ğ•‹$. In other words, $\mathtt{filter}$
   should satisfy the following equivalences:
   $$\mathtt{filter}\,f\,âŒœ[]âŒ â‰¡_Î² âŒœ[]âŒ$$
   $$\mathtt{filter}\,f\,âŒœa : lâŒ â‰¡_Î² Î»c, n.c\,âŒœaâŒ\,(\mathtt{filter}\,f\,âŒœlâŒ\,c\,n)\,\,\,\,\,\,\,\,\,\,\,\,\text{(if }f\,âŒœaâŒ â†’_Î²^* ğ•‹\text{)}$$
   $$\mathtt{filter}\,f\,âŒœa : lâŒ â‰¡_Î² \mathtt{filter}\,f\,âŒœlâŒ\,\,\,\,\,\,\,\,\,\,\,\,\text{(if }f\,âŒœaâŒ â†’_Î²^* ğ”½\text{)}$$
