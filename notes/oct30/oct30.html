<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-11-10 Fri 23:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Analytic tableaux</title>
<meta name="author" content="Julian Grove" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
<script src="../../jquery.min.js"></script>
<script src="../../bootstrap.min.js"></script>
<script type="text/javascript" src="../../readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Analytic tableaux</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2214139">1. Rules</a>
<ul>
<li><a href="#orga4e6a99">1.1. Conjunction rules</a></li>
<li><a href="#org6d987a5">1.2. Disjunction rules</a></li>
<li><a href="#orgb920970">1.3. Negation rules</a></li>
<li><a href="#org3d9aec4">1.4. γ rules</a></li>
<li><a href="#org230c6fd">1.5. δ rules</a></li>
</ul>
</li>
<li><a href="#orgf4ec36b">2. An example</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2214139" class="outline-2">
<h2 id="org2214139"><span class="section-number-2">1.</span> Rules</h2>
<div class="outline-text-2" id="text-1">
<p>
We've begun discussing analytic tableaux, which provide a method of proving
contradictions in (classical) first-order logic by breaking (signed) formulae
down into smaller (signed) formulae, according to both the sign and the main
connective of the relevant formula.
</p>

<p>
Using this method, we represent the results of breaking a formula down into
pieces as a tableau. A tableau is just a tree whose nodes are signed formulae.
The rules associated with each connective provide general schema for <i>expanding</i>
some tableau, i.e., by somehow adding new signed formulae to it.
</p>

<p>
Each connective, \(∧\), \(∨\), \(¬\), \(∀\), and \(∃\) has its own set of rules, as
follows. Here, each rule is represented by a tree containing the
<i>to-be-expanded</i> node as the root node and the formulae that a given tableau is
expanded with as child nodes.
</p>
</div>

<div id="outline-container-orga4e6a99" class="outline-3">
<h3 id="orga4e6a99"><span class="section-number-3">1.1.</span> Conjunction rules</h3>
<div class="outline-text-3" id="text-1-1">

<div id="org70dabdf" class="figure">
<p><img src="./andrules.png" alt="andrules.png" width="300" />
</p>
</div>

<p>
True conjunctions are expanded by introducing child nodes on which each of
the conjuncts is true.
</p>

<p>
False conjunctions cause a given path of the tableau to branch into two
paths: one in which the left conjunct is false, and one in which the right
conjunct is false. Thus to show that the the tableau is contradictory, we
need to show that a contradiction is introduced along both paths, since we
don't know which conjunct is false.
</p>
</div>
</div>

<div id="outline-container-org6d987a5" class="outline-3">
<h3 id="org6d987a5"><span class="section-number-3">1.2.</span> Disjunction rules</h3>
<div class="outline-text-3" id="text-1-2">

<div id="org6014438" class="figure">
<p><img src="./orrules.png" alt="orrules.png" width="300" />
</p>
</div>

<p>
True disjunctions are expanded by branching into two separate paths, one
where each disjunct is true. That is, to show that a disjunction results in a
contradiction, it is sufficient to show that <i>both</i> of its disjuncts lead to a
contradiction.
</p>

<p>
False disjunctions branch by making each disjunct false along the same path.
</p>
</div>
</div>

<div id="outline-container-orgb920970" class="outline-3">
<h3 id="orgb920970"><span class="section-number-3">1.3.</span> Negation rules</h3>
<div class="outline-text-3" id="text-1-3">

<div id="orgf7af175" class="figure">
<p><img src="./notrules.png" alt="notrules.png" width="250" />
</p>
</div>

<p>
A true negation becomes an unnegated false thing, and a false negation
becomes an unnegated true thing!
</p>
</div>
</div>

<div id="outline-container-org3d9aec4" class="outline-3">
<h3 id="org3d9aec4"><span class="section-number-3">1.4.</span> γ rules</h3>
<div class="outline-text-3" id="text-1-4">

<div id="org0da93eb" class="figure">
<p><img src="./gammarules.png" alt="gammarules.png" width="300" />
</p>
</div>

<p>
If it is true that every \(x\) is such that \(φ(x)\), you can pick any name \(n\)
you want and expand the path by saying it is true that \(φ(n)\), since \(φ\) will
certainly be true of \(n\).
</p>

<p>
If it is false that some \(x\) is such that \(φ(x)\), you can pick any name \(n\)
you want and expand the path by saying it is false that \(φ(n)\), since \(φ\)
will be false of \(n\) (if it were true of \(n\), then there would be some \(n\)
such that \(φ(n)\) and \((∃x.φ(x))\) would be true).
</p>
</div>
</div>

<div id="outline-container-org230c6fd" class="outline-3">
<h3 id="org230c6fd"><span class="section-number-3">1.5.</span> δ rules</h3>
<div class="outline-text-3" id="text-1-5">

<div id="org319442d" class="figure">
<p><img src="./deltarules.png" alt="deltarules.png" width="300" />
</p>
</div>

<p>
If it is false that every \(x\) is such that \(φ(x)\), that means there must be
some \(x\) such that it is false that \(φ(x)\) (if there weren't such an \(x\),
then it would be <i>true</i> that every \(x\) is such that \(φ(x)\)). Since we don't
know which \(x\) makes the universal statement false, we should just expand the
path by picking a fresh name \(n_{\text{fresh}}\), i.e., which hasn't occurred
anywhere on the path yet, and saying it is false that \(φ(n_{\text{fresh}})\).
</p>

<p>
Similar reasoning applies to a true existential formula. If it is true that
there is some \(x\) such that \(φ(x)\), then we should add \(φ(n_{\text{fresh}})\),
for some name \(n_{\text{fresh}}\) which hasn't occurred yet anywhere on the
path. In other words, it doesn't matter what we call the relevant \(x\), as
long as we haven't identified it with anything else we've made claims about
on the same path.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf4ec36b" class="outline-2">
<h2 id="orgf4ec36b"><span class="section-number-2">2.</span> An example</h2>
<div class="outline-text-2" id="text-2">
<p>
Goal: show that \((∀x.P(x) → (∃y.P(y)))\) is a theorem.
</p>

<div id="org5602b34" class="figure">
<p><img src="./example.png" alt="example.png" width="300" />
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Julian Grove</p>
<p class="date">Created: 2023-11-10 Fri 23:34</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
