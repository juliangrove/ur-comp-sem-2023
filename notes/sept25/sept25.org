#+html_head: <link rel="stylesheet" type="text/css" href="../../htmlize.css"/>
#+html_head: <link rel="stylesheet" type="text/css" href="../../readtheorg.css"/>
#+html_head: <script src="../../jquery.min.js"></script>
#+html_head: <script src="../../bootstrap.min.js"></script>
#+html_head: <script type="text/javascript" src="../../readtheorg.js"></script>

#+Author: Julian Grove
#+Title: While you were partying, I studied the Î»-calculus

* Review
  Today's goal was to give ourselves the tools to define recursive functions in
  the untyped Î»-calculus, using the /factorial/ function on natural numbers as an
  illustrative example. This function can be defined as follows in Haskell:
  #+begin_src haskell
    factorial :: Nat -> Nat
    factorial n = if n == Zero then Succ Zero else mult n (factorial (pred n))
      where mult :: Nat -> Nat -> Nat
	    mult Zero n = Zero
	    mult (Succ m) n = plus n (mult m n)

            plus :: Nat -> Nat -> Nat
	    plus Zero n = n
	    plus (Succ m) n = Succ (plus n m)

	    pred :: Nat -> Nat
	    pred Zero = Zero
	    pred (Succ n) = n
  #+end_src
  Crucially, this definition of ~factorial~ makes a recursive call to ~factorial~,
  i.e., inside the second branch of the ~if~ statement. Thus when we define this
  function in the Î»-calculus, we'll want to have a way of making recursive calls
  of this kind:
  $$\mathtt{factorial} â‰ Î»n.\mathtt{ifThenElse}\,(\mathtt{isZero}\,n)\,âŒœ1âŒ\,
  (\mathtt{mult}\,n\,(\mathtt{factorial}\,(\mathtt{pred}\,n)))$$

  Before we get there, let's look at the two functions $\mathtt{factorial}$ uses
  which we haven't previously defined: $\mathtt{isZero}$ and $\mathtt{pred}$.

** $\mathtt{isZero}$
   We want to define $\mathtt{isZero}$ in such a way that, given some argument
   $n = Î»s, z.â€¦$ , it passes $n$ two arguments in a way that causes it to
   return $ğ•‹$ if $n$ is $âŒœ0âŒ$ and $ğ”½$ if $n$ is some larger number. The
   following definition does the trick:
   $$\mathtt{isZero} â‰ Î»n.n\,(Î»b.ğ”½)\,ğ•‹$$
   If $n$ is $âŒœ0âŒ$, it will return its second argument, $ğ•‹$; if $n$ is some
   other number, it will return the result of applying $Î»b.ğ”½$ to whatever is the
   argument of the highest bound $s$, giving back $ğ”½$.

** $\mathtt{pred}$
   We want to define $\mathtt{pred}$ in such a way that, given an argument $n =
   Î»s, z.s\,(m\,s\,z)$, it simply gives back $m$ (i.e., \(n\)'s predecessor).
   The following definition does this:
   $$\mathtt{pred} â‰ Î»n.Ï€_1\,(n\,(Î»p.âŸ¨Ï€_2\,p, \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,âŸ¨âŒœ0âŒ,
   âŒœ0âŒâŸ©)$$
   It's easiest to see why this definition works by looking at examples. Taking
   the predecessor of $âŒœ0âŒ$, for instance, gives the following result:
   $$\mathtt{pred}\,âŒœ0âŒ$$
   $$â†’_Î²\,\,\,Ï€_1\,(âŒœ0âŒ\,(Î»p.âŸ¨Ï€_2\,p, \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,âŸ¨âŒœ0âŒ, âŒœ0âŒâŸ©)$$
   $$=\,\,\,Ï€_1\,((Î»s, z.z)\,(Î»p.âŸ¨Ï€_2\,p, \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,âŸ¨âŒœ0âŒ,
   âŒœ0âŒâŸ©)$$
   $$â†’_Î²^*\,\,\,Ï€_1\,âŸ¨âŒœ0âŒ, âŒœ0âŒâŸ©$$
   $$â†’_Î²^*\,\,\,âŒœ0âŒ$$
   In other words, the predecessor of $âŒœ0âŒ$ is just $âŒœ0âŒ$, according to
   $\mathtt{pred}$. If instead we take the predecessor of, say, $âŒœ2âŒ$, we'd get
   the following result:
   $$\mathtt{pred}\,âŒœ2âŒ$$
   $$â†’_Î²^*\,\,\,\mathtt{pred}\,(Î»s, z.s\,(s\,z))$$
   $$â†’_Î²\,\,\,Ï€_1\,((Î»s, z.s\,(s\,z))\,(Î»p.âŸ¨Ï€_2\,p,
   \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,âŸ¨âŒœ0âŒ, âŒœ0âŒâŸ©)$$
   $$â†’_Î²\,\,\,Ï€_1\,((Î»z.(Î»p.âŸ¨Ï€_2\,p, \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,((Î»p.âŸ¨Ï€_2\,p,
   \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,z))\,âŸ¨âŒœ0âŒ, âŒœ0âŒâŸ©)$$
   $$â†’_Î²\,\,\,Ï€_1\,((Î»p.âŸ¨Ï€_2\,p, \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,((Î»p.âŸ¨Ï€_2\,p,
   \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,âŸ¨âŒœ0âŒ, âŒœ0âŒâŸ©))$$
   There are now two Î²-redices. Targeting the more embedded one first gives us
   $$â†’_Î²\,\,\,Ï€_1\,((Î»p.âŸ¨Ï€_2\,p,
   \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,{(\color{red}(Î»p.âŸ¨Ï€_2\,p,\mathtt{succ}\,(Ï€_2\,p)âŸ©)\,âŸ¨âŒœ0âŒ,
   âŒœ0âŒâŸ©)})$$
   $$â†’_Î²^*\,\,\,Ï€_1\,((Î»p.âŸ¨Ï€_2\,p, \mathtt{succ}\,(Ï€_2\,p)âŸ©)\,âŸ¨âŒœ0âŒ,
   \mathtt{succ}\,âŒœ0âŒâŸ©)$$
   $$â†’_Î²^*\,\,\,Ï€_1\,\,âŸ¨\mathtt{succ}\,âŒœ0âŒ,
   \mathtt{succ}\,(\mathtt{succ}\,âŒœ0âŒ)âŸ©$$
   $$â†’_Î²^*\,\,\,\mathtt{succ}\,âŒœ0âŒ$$
   $$â†’_Î²^*\,\,\,Î»s, z.s\,z$$
   In other words, the predecessor of $âŒœ2âŒ$ is (Î²-equivalent to) $âŒœ1âŒ$.

** Fixed points
   To make recursive calls in the Î»-calculus, we will define recursive functions
   as /fixed points/. A fixed point of a function $f$ is a value $x$ such that
   $f\,x = x$. We will find fixed points of functions by using a /fixed point
   combinator/; that is, some function $F$ which when applied to $f$, gives back
   such an $x$. That is, we want $F$ to be such that
   $$f\,(F\,f) â‰¡_Î² F\,f$$
   The reason we can define recursive functions, such as $\mathtt{factorial}$,
   as fixed points is because their definitions have the following shape, in
   general, for some $M$:
   $$\mathtt{factorial} = M[x:=\mathtt{factorial}]$$
   Here, $x$ just marks wherever the recursive call is actually made inside $M$.
   In the case of $\mathtt{factorial}$, $x$ would be inside the second branch of
   the $\mathtt{ifThenElse}$ statement---the part that says
   `\(\mathtt{factorial}\)'. Viewing $\mathtt{factorial}$ this way allows us to
   define it as the following fixed point:
   $$\mathtt{factorial} â‰ F\,(Î»x.M)$$
   Why? Because now, we know that its definition satisfies the following
   equivalence:
   $$F\,(Î»x.M) â‰¡_Î² (Î»x.M)\,(F\,(Î»x.M))$$
   $$â–¹_Î²\,\,\,M[x:=F\,(Î»x.M)]$$
   That is, we have that $\mathtt{factorial} â‰¡_Î² M[x:=\mathtt{factorial}]$!

   This discussion gives us a general recipe for defining recursive functions:
   - Step 1: give a single-line definition of the function using an indentifier,
     which somewhere makes a call to itself, just like we did for
     $\mathtt{factorial}$ in Â§[[Review]].
   - Step 2: stick a fresh variable into the position(s) of the call, and
     immediately abstract over it at the top of the definition-in-progress.
   - Step 3: apply a fixed-point combinator $F$ to the result.
   - Step 4: profit???

   Given some fixed-point combinator $F$ that does the job, we can, using this
   recipe, define $\mathtt{factorial}$ as the following fixed point:
   $$\mathtt{factorial} â‰ F\,(Î»x,
   n.\mathtt{ifThenElse}\,(\mathtt{isZero}\,n)\,âŒœ1âŒ\,(\mathtt{mult}\,n\,(x\,(\mathtt{pred}\,n))))$$

** The \(Y\)-combinator
   Crucially, we can define a fixed-point combinator, i.e., which behaves like
   $F$. The following is what is known as the \(Y\)-combinator:
   $$Y â‰ Î»f.(Î»x.f\,(x\,x))\,(Î»x.f\,(x\,x))$$
   Note that, for any $f$, we have
   $$Y\,f$$
   $$=\,\,\,(Î»f.(Î»x.f\,(x\,x))\,(Î»x.f\,(x\,x)))\,f$$
   $$â–¹_Î²\,\,\,(Î»x.f\,(x\,x))\,(Î»x.f\,(x\,x))$$
   $$â–¹_Î²\,\,\,f\,((Î»x.f\,(x\,x))\,(Î»x.f\,(x\,x)))$$
   $$â‰¡_Î²\,\,\,f\,(Y\,f)$$
   So, for example, $Y$ can go in place of $F$ up above in the definition
   $\mathtt{factorial}$.

   To illustrate this all in action, let's compute (most of) $\mathtt{factorial}\,âŒœ3âŒ$.
   $$\mathtt{factorial}\,âŒœ3âŒ$$
   $$=\,\,\,Y\,(Î»x,
   n.\mathtt{ifThenElse}\,(\mathtt{isZero}\,n)\,âŒœ1âŒ\,(\mathtt{mult}\,n\,(x\,(\mathtt{pred}\,n))))\,âŒœ3âŒ$$
   Given the demonstration above, we can continue this as
   $$â‰¡_Î²\,\,\,(Î»x,
   n.\mathtt{ifThenElse}\,(\mathtt{isZero}\,n)\,âŒœ1âŒ\,(\mathtt{mult}\,n\,(x\,(\mathtt{pred}\,n))))\,\mathtt{factorial}\,âŒœ3âŒ$$
   $$â†’_Î²\,\,\,(Î»n.\mathtt{ifThenElse}\,(\mathtt{isZero}\,n)\,âŒœ1âŒ\,(\mathtt{mult}\,n\,(\mathtt{factorial}\,(\mathtt{pred}\,n))))\,âŒœ3âŒ$$
   $$â†’_Î²\,\,\,\mathtt{ifThenElse}\,(\mathtt{isZero}\,âŒœ3âŒ)\,âŒœ1âŒ\,(\mathtt{mult}\,âŒœ3âŒ\,(\mathtt{factorial}\,(\mathtt{pred}\,\,âŒœ3âŒ)))$$
   $$â†’_Î²^*\,\,\,\mathtt{mult}\,âŒœ3âŒ\,(\mathtt{factorial}\,(\mathtt{pred}\,\,âŒœ3âŒ))$$
   $$â‰¡_Î²\,\,\,\mathtt{mult}\,âŒœ3âŒ\,(\mathtt{factorial}\,âŒœ2âŒ)$$
   $$â‰¡_Î²\,\,\,\mathtt{mult}\,âŒœ3âŒ\,((Î»x,
   n.\mathtt{ifThenElse}\,(\mathtt{isZero}\,n)\,âŒœ1âŒ\,(\mathtt{mult}\,n\,(x\,(\mathtt{pred}\,n))))\,\mathtt{factorial}\,âŒœ2âŒ)$$
   $$â†’_Î²\,\,\,\mathtt{mult}\,âŒœ3âŒ\,((Î»n.\mathtt{ifThenElse}\,(\mathtt{isZero}\,n)\,âŒœ1âŒ\,(\mathtt{mult}\,n\,(\mathtt{factorial}\,(\mathtt{pred}\,n))))\,âŒœ2âŒ)$$
   $$â†’_Î²\,\,\,\mathtt{mult}\,âŒœ3âŒ\,(\mathtt{ifThenElse}\,(\mathtt{isZero}\,âŒœ2âŒ)\,âŒœ1âŒ\,(\mathtt{mult}\,âŒœ2âŒ\,(\mathtt{factorial}\,(\mathtt{pred}\,âŒœ2âŒ))))$$
   $$â†’_Î²^*\,\,\,\mathtt{mult}\,âŒœ3âŒ\,(\mathtt{mult}\,âŒœ2âŒ\,(\mathtt{factorial}\,(\mathtt{pred}\,âŒœ2âŒ)))$$
   $$â‰¡_Î²\,\,\,\mathtt{mult}\,âŒœ3âŒ\,(\mathtt{mult}\,âŒœ2âŒ\,(\mathtt{factorial}\,âŒœ1âŒ))$$
   and so on, until we get to
   $$â‰¡_Î²\,\,\,\mathtt{mult}\,âŒœ3âŒ\,(\mathtt{mult}\,âŒœ2âŒ\,âŒœ1âŒ)$$
   $$â‰¡_Î² âŒœ6âŒ$$

** More combinators
   Recall the definition of a fixed point combinator $F$:
   $$F\,f â‰¡_Î² f\,(F\,f)$$
   where $f$ is arbitrary. What's kind of interesting about this definition is
   that it almost looks kind of like a recursive equation. Here's how. Let's
   first abstract over the $f$ on both sides of the equivalence to get the
   following equivalence instead:
   $$Î»f.F\,f â‰¡_Î² Î»f.f\,(F\,f)$$
   Notice that the left side is now an Î·-redex, which we can contract:
   $$F â‰¡_{Î²Î·} Î»f.f\,(F\,f)$$
   That is, a fixed-point combinator /itself/ has a definition that makes it look
   like a kind of fixed point. Specifically it is the fixed point of 
   $$Î»x, f.f\,(x\,f)$$
   Given that we already have a fixed-fixed point combinator $Y$, we can get the
   fixed point of this function by applying $Y$ to it:
   $$Y\,(Î»x, f.f\,(x\,f))$$
   $$=\,\,\,(Î»f.(Î»x.f\,(x\,x))\,(Î»x.f\,(x\,x)))\,(Î»x, f.f\,(x\,f))$$
   $$â†’_Î²\,\,\,(Î»x.(Î»x, f.f\,(x\,f))\,(x\,x))\,(Î»x.(Î»x, f.f\,(x\,f))\,(x\,x))$$
   $$â†’_Î²^*\,\,\,(Î»x, f.f\,(x\,x\,f)))\,(Î»x, f.f\,(x\,x\,f))$$
   Note that if we define the abbreviation
   $$Î¸ â‰ Î»x, f.f\,(x\,x\,f)$$
   then we can define the above combinator as simply $Î¸\,Î¸$.
   
* Exercises
** Part 1
   One of the things we saw how to do with a list is take its first element via
   $\mathtt{head}$.
   $$\mathtt{head} â‰ Î»l.l\,ğ•‹\,ğ”½$$
   Can you define a function $\mathtt{tail}$ which takes the /tail/ of a list?
   That is, it should behave as follows:
   $$\mathtt{tail}\,âŒœ[]âŒ â‰¡_Î² âŒœ[]âŒ$$
   $$\mathtt{tail}\,âŒœa : lâŒ â‰¡_Î² âŒœlâŒ$$
   Hint: remember $\mathtt{pred}$?!

** Part 2
   Define $\mathtt{filter}$ from the last assignment as a fixed point.
